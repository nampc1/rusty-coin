# 1. Operator Overloading for Custom Types

**Context:** We need to implement standard arithmetic operators (`+`, `-`, `*`, `/`) for our custom numeric types like `FieldElement` and `Point`.

**Decision:** To provide maximum performance and ergonomic flexibility, we follow a standard four-part pattern for implementing binary operators on a type `T`.

## The Pattern

1.  **Core Logic on References (`&T + &T`):**
    The primary implementation is `impl Add for &T`. This version takes both operands by reference, which avoids consuming the values and prevents unnecessary moves or clones. All computational logic resides here.

    ```rust
    impl Add for &FieldElement {
        // ... logic ...
    }
    ```

2.  **Ergonomic Wrappers:**
    The other three implementations exist purely for user convenience. They allow for natural-looking code (e.g., `a + b`) and simply delegate to the core reference-based implementation.

    -   `impl Add for T` (for `value + value`)
    -   `impl Add<&T> for T` (for `value + &reference`)
    -   `impl Add<T> for &T` (for `&reference + value`)

**Rationale:** This pattern is idiomatic in Rust. It gives users a seamless experience, making custom types feel like built-in numbers. It also explicitly resolves method ambiguity for the compiler, which might otherwise struggle to choose between multiple valid reference-based implementations. For maintainability, the three wrapper implementations can be generated by a macro to reduce boilerplate code.